
# 选择排序

特点:交换次数最少的算法，线性级别

# 插入排序

```C++
void insertsort(){
    for(int i=1;i<n;i++){
        int tmp=a[i];
        int k;
        for(k=i-1;k>=0;k--){
            if(a[k]>tmp){
                a[k+1]=a[k];//移动而不是交换，能够提高效率
            }else{//注意要break
                break;
            }
        }
        a[k+1]=tmp;
    }
}

```

特点

- 适合非随机的数组 部分有序的数组 小规模数组
- 基本上会比选择排序方法快一倍


# 希尔排序


```
void shellsort(){
    int d=n/2;
    while(d>0){//不能是>1
        for(int i=d;i<n;i+=1){//这里的步进是d
            int tmp=a[i];
            int k;
            for(k=i-d;k>=0;k-=d){
                if(a[k]>tmp){
                    a[k+d]=a[k];
                }else{
                    break;
                }
            }
            a[k+d]=tmp;
        }
        d/=2;
    }
}
```

特点

- 算法的证明或者研究十分困难
- 思想是先让任意间隔d的元素有序,如果d很大，那么就能够交换距离比较远的元素
- 其他思路和插入排序相同


# bottom_up归并排序

- 自底向上的归并排序
  - 说明：最后一个子数组的大小只有是在n的偶数倍的时候才会等于n，否则会比n小
  - 以下算法使用的是闭区间
```C++
void merge(int lo, int mid, int hi) {
    // copy to aux[]
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k]; 
    }
    // merge back to a[]
    int i = lo, j = mid+1;
    for (int k = lo; k <= hi; k++) {
        if      (i > mid)              a[k] = aux[j++];  // this copying is unneccessary
        else if (j > hi)               a[k] = aux[i++];
        else if (aux[j] < aux[i])      a[k] = aux[j++];
        else                           a[k] = aux[i++];
    }
}
void sort() {
    for (int n = 1; n < N; n = n+n) {
        for (int i = 0; i < N-n; i += n+n) {
            int lo = i;
            int m  = i+n-1;
            int hi = min(i+n+n-1, N-1);
            merge(a, aux, lo, m, hi);
        }
    }
}

```


# 快速排序

### java的实现

```
void sort(int lo, int hi) { //闭区间
    if (hi <= lo) return;
    int j = partition(lo, hi);
    sort(lo, j-1);
    sort(j+1, hi);
}

// partition the subarray a[lo..hi] so that a[lo..j-1] <= a[j] <= a[j+1..hi]
// and return the index j.
private static int partition(int lo, int hi) {
    int i = lo;
    int j = hi + 1;
    int v = a[lo];
    while (true) { 

        // find item on lo to swap
        while (a[++i] < v))
            if (i == hi) break;

        // find item on hi to swap
        while (v < a[--j]))
            if (j == lo) break;      // redundant since a[lo] acts as sentinel

        // check if pointers cross
        if (i >= j) break;

        exch(a, i, j);
    }

    // put partitioning item v at a[j]
    exchange(a, lo, j);

    // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
    return j;
}
```



### 三向切分的快速排序

![图片](http://algs4.cs.princeton.edu/23quicksort/images/partitioning3-overview.png)

# [索引优先队列](indexpriorityqueue.cpp)

# 排序算法总结
![图片](http://algs4.cs.princeton.edu/25applications/images/sort-characteristics.png)

