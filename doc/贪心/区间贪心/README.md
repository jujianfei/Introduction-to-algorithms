## POJ3069

直线上有n个点，位置是xi，从中选择ans个点，给他们加上标记，对于每一个点，其距离为R以内的区域必须带有标记，（自己带有标记，认为距离为0的区域内有标记）在满足这个条件的前提下，求ans的最小值？

思路：选择一个点之后，一直向右找，一直不能够覆盖为止，然后确定下一个点，重复上述过程。

```C++
scanf("%d%d",&r,&n);
        if(r==-1&&n==-1)break;
        for(int i=0;i<n;i++){
            scanf("%d",&a[i]);
        }
        sort(a,a+n);
        int ans=0;
        int begin=0;
        while(begin<n){
            ans++;
            int p=begin;
            while(p<n&&a[begin]+r>=a[p+1]){p++;}
            int next=p;
            while(next<n&&a[p]+r>=a[next+1]){next++;}
            begin=next+1;
        }
        cout<<ans<<endl;
```
- 注意：最重要的是边界条件的检查

- 在这一道题里面是>=和>的区别。

## POJ1328

题意：尽可能少的安装雷达。
选择最左边的未被覆盖的点然后让覆盖它的那个圆尽可能向右移（这样可能覆盖更多的点），这个算法是错的。
考虑下面这个数据就知道这个算法是错的了：
2 3
0 2
1 3
正确结果是1，这个算法输出2。

正确的是根据某个点的位置，确定出雷达可以安装的区间，然后转化成区间选点问题这个模型
数轴上有n个区间，选择尽量少的点，让每个区间都至少有一个点

解法，将区间按照右端点从小到大排序，如果右端点相同，按照左端点从大到小排序。
贪心策略选取最后一个点。

```
         int count=1;
         int m=0;//现在所在的地点
         for(int i=1;i<n;i++){
             if(a[i].a<=a[m].a)continue;
             if(a[m].b<=a[i].b && a[m].b>=a[i].a)continue;
             else{
                 count++;
                 m=i;
             }
         }
         cout<<count<<endl;
```

## POJ2376

区间覆盖问题

数轴上有n个闭区间，选择尽量少的区间覆盖整个数轴
如果不能覆盖输出-1

贪心策略：

    按照区间的左端点排序，

    第一个区间的开始不是1，无解，选择起点在s的最长的区间，然后下一个起点，是这个所选择区间的右端点。

```
    sort(a+1,a+n+1,cmp);//排序
    a[n+1].x=0x7fffffff;
    //t-是上次结尾的值，tmp，临时结尾最大值，ans，结果
    int t=0,tmp=0,ans=0;
    bool f=0;//是否更新的标志位
    for (int i=1;i<=n;++i)
    {
        //如果起点满足题意
        if (a[i].x<=t+1){
                //对于起点满足题意的，更新终点的最大值
                if (tmp<a[i].y)
                     tmp=a[i].y,f=1;
                //预判：如果下一个点不满足题意了，而且终点是更新过的，那么答案加1，如果下一个节点不满足题意，终点没有更新过，（也就是说出现了终点相同的情况，那么不增加）
                if (a[i+1].x>t+1 && f)
                    t=tmp,++ans,f=0;
            }
    }
    if (t<T)
     printf("-1\n"); else printf("%d\n",ans);
```

- 注释：巧妙的一点在于，结尾的判断，将结尾的元素的起点置为INF，可以巧妙的结束，不用再判断是否结尾。

##  nyist14

尽量多的选择不相交的区间

按照b1<=b2<=b3…的方式排序，然后从前向后遍历，每当遇到可以加入集合的区间，就把它加入集合。（集合代表解的集合）

证明：

我们对a1,a2……的关系分以下几种情况考虑：

1、a1>a2。此时区间2包含区间1。

这种情况下显然不会选择区间2，因为选择区间1会留下更多的剩余空间。

不仅区间2如此，以后所有区间中只要有一个 i 满足a1 > ai，i 都不要选。

即此种情况下，选择区间1是明智的，与策略一致。

2、排除情况1后，一定有a1<=a2<=a3……。


## 最多区间调度

有n项工作，每项工作分别在时间开始，在时间结束。对于每项工作，你都可以选择参与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重叠（闭区间）。你的目标是参与尽可能多的工作，那么最多能参与多少项工作？其中并且。（from《挑战程序设计竞赛 P40》）

这个区间问题就是大家熟知的区间调度问题或者叫最大区间调度问题。在此我们进行细分，将该问题命名为最多区间调度问题，因为该问题的目标是求不重叠的最多区间个数，而不是最大的区间长度和。

这个问题可以算是最简单的区间调度问题了，可以通过贪心算法求解，贪心策略是：在可选的工作中，每次都选取结束时间最早的工作。其他贪心策略都不是最优的。

```C++
const int MAX_N=100000;  
//输入  
int N,S[MAX_N],T[MAX_N];  
//用于对工作排序的pair数组  
pair<int,int> itv[MAX_N];  
void solve()  
{  
    //对pair进行的是字典序比较，为了让结束时间早的工作排在前面，把T存入first，//把S存入second  
    for(int i=0;i<N;i++)  
    {  
        itv[i].first=T[i];  
        itv[i].second=S[i];  
    }  
    sort(itv,itv+N);  
    //t是最后所选工作的结束时间  
    int ans=0,t=0;  
    for(int i=0;i<N;i++)  
    {  
        if(t<itv[i].second)//判断区间是否重叠  
        {  
            ans++;  
            t=itv[i].first;  
        }  
    }  
    printf(“%d\n”,ans);  
}  
```

## Pr

- POJ-2376-Cleaning_Shifts
- POJ-1328-Radar_Installation
- POJ-3190-Stall_Reservations