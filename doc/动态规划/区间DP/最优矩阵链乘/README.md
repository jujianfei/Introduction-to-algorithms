## 最优矩阵链乘。 

一个n×m矩阵由n行m列共个数排列而成。 两个矩阵A和B可以相乘当且仅当A的列数等于B的行数。 

一个n×m的矩阵乘以一个m×p的矩阵等于一个的矩阵，运算量为mnp。

矩阵乘法不满足分配律，但满足结合律，因此A×B×C既可以按顺序(A×B)×C进行，也可以按A×(B×C)进行。

假设A、 B、 C分别是2×3，3×4和4×5的，则(A×B)×C的运算量为2×3×4＋2×4×5＝64，A×(B×C)的运算量为3×4×5＋2×3×5＝90。

显然第一种顺序节省运算量。给出n个矩阵组成的序列，设计一种方法把它们依次乘起来，使得总的运算量尽量小。

假设第i个矩阵Ai是p_(i-1) * P_(i)的。

【分析】

本题任务是设计一个表达式。 在整个表达式中，一定有一个“最后一次乘法”。 假设它是第k个乘号，则在此之前已经算出了P=A1 * A2 * A3 * ... * AK 和 Q = A_(K+1) * A_(K+2) * ... A(n)。 由于P和Q的计算过程互不相干，而且无论按照怎样的顺序，P和Q的值都不会发生改变，因此只需分别让P和Q按照最优方案计算（最优子结构！）即可。 

为了计算P的最优方案，还需要继续枚举的“最后一次乘法”，把它分成两部分。 

不难发现，无论怎么分，在任意时候，需要处理的子问题都形如“把A_i，A_(i+1)，…，A_j乘起来需要多少次乘法？”如果用状态f(i, j)表示这个子问题的值，不难列出如下的状态转移方程：

```
f(i, j) = min{f(i, k) + f(k+1, j) + p_(i-1) * p_(k) * p_(j)}
```

边界为f(i, i)=0。 

上述方程有些特殊：记忆化搜索固然没问题，但如果要写成递推，无论按照i还是j的递增或递减顺序均不正确。 正确的方法是按照j－i递增的顺序递推，因为长区间的值依赖于短区间的值。