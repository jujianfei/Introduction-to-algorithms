DAG最长（短）路的特殊性，有两种“对称”的状态定义方式。

状态1：设d(i)为从i出发的最长路，则 d(i) = max{d(j)+1|(i,j)<-E}。
状态2：设d(i)为以i结束的最长路，则 d(i) = max{d(j)+1|(j,i)<-E}。

如果使用状态2，“硬币问题”就变得和“嵌套矩形问题”几乎一样了。
（唯一的区别是：“嵌套矩形问题”还需要取所有d(i)的最大值）！

状态1不推荐使用。

使用状态2时，有时还会遇到一个问题：状态转移方程可能不好计算，因为在很多时候，可以方便地枚举从某个结点i出发的所有边(i,j)，却不方便“反着”枚举(j,i)。 特别是在有些题目中，这些边具有明显的实际背景，对应的过程不可逆。这时需要用“刷表法”。 什么是“刷表法”呢？传统的递推法可以表示成“对于每个状态i，计算f(i)”，或者称为“填表法”。 这需要对于每个状态i，找到f(i)依赖的所有状态，在某些情况下并不方便。 另一种方法是“对于每个状态i，更新f(i)所影响到的状态”，或者称为“刷表法”。 对应到DAG最长路的问题中，就相当于按照拓扑序枚举i，对于每个i，枚举边(i,j)，然后更新d[j] = max(d[j] , d[i]＋1)。 注意，一般不把这个式子叫做“状态转移方程”，因为它不是一个可以直接计算d[j]的方程，而只是一个更新公式。


传统的递推法可以表示成“对于每个状态i，计算f(i)”，或者称为“填表法”。这需要对于每个状态i，找到f(i)依赖的所有状态，在某些时候并不方便。 另一种方法是“对于每个状态i，更新f(i)所影响到的状态”，或者称为“刷表法”，有时比填表法方便。 但需要注意的是，只有当每个状态所依赖的状态对它的影响相互独立时才能用刷表法。

## Pr

- UVA-1025-城市里的间谍
- UVA-437-巴比伦塔，摞立方体
- UVA-1347-旅行（难理解）

