##顺序单链表的算法

* 就地逆置


```
ListNode* reverseList(ListNode* head) {
    if(!head)return head;
    if(!head->next)return head;
    auto p=head;
   	ListNode* pre=nullptr;
    while(p){
        auto q=p->next;
        p->next=pre;
        pre=p;
        p=q;
        
    }
    return pre;
}
```

##[顺序单链表的应用_实现字典](template_linklistst.h)

##[顺序单链表的应用_多项式加法](polynomial_add.cpp)

##[顺序循环双链表的实现](binarylooplist.cpp)

##[用数组模拟顺序单链表的实现](simulate_list.cpp)

这里我们采用数组模拟单链表，同样我们为了能够方便的进行插入删除查找，设置一个头指针head，这个head并没有任何意义，只是为了操作方便，同时为了模拟堆中的free和new我们设定两个私有函数```free`和````get_first_empty`进行模拟。
	
