## POJ3069

直线上有n个点，位置是xi，从中选择ans个点，给他们加上标记，对于每一个点，其距离为R以内的区域必须带有标记，（自己带有标记，认为距离为0的区域内有标记）在满足这个条件的前提下，求ans的最小值？

思路：选择一个点之后，一直向右找，一直不能够覆盖为止，然后确定下一个点，重复上述过程。

```C++
scanf("%d%d",&r,&n);
        if(r==-1&&n==-1)break;
        for(int i=0;i<n;i++){
            scanf("%d",&a[i]);
        }
        sort(a,a+n);
        int ans=0;
        int begin=0;
        while(begin<n){
            ans++;
            int p=begin;
            while(p<n&&a[begin]+r>=a[p+1]){p++;}
            int next=p;
            while(next<n&&a[p]+r>=a[next+1]){next++;}
            begin=next+1;
        }
        cout<<ans<<endl;
```
- 注意：最重要的是边界条件的检查

- 在这一道题里面是>=和>的区别。

## POJ1328

题意：尽可能少的安装雷达。
选择最左边的未被覆盖的点然后让覆盖它的那个圆尽可能向右移（这样可能覆盖更多的点），这个算法是错的。
考虑下面这个数据就知道这个算法是错的了：
2 3
0 2
1 3
正确结果是1，这个算法输出2。

正确的是根据某个点的位置，确定出雷达可以安装的区间，然后转化成区间选点问题这个模型
数轴上有n个区间，选择尽量少的点，让每个区间都至少有一个点

解法，将区间按照右端点从小到大排序，如果右端点相同，按照左端点从大到小排序。
贪心策略选取最后一个点。

```
         int count=1;
         int m=0;//现在所在的地点
         for(int i=1;i<n;i++){
             if(a[i].a<=a[m].a)continue;
             if(a[m].b<=a[i].b && a[m].b>=a[i].a)continue;
             else{
                 count++;
                 m=i;
             }
         }
         cout<<count<<endl;
```

## POJ2376

区间覆盖问题

数轴上有n个闭区间，选择尽量少的区间覆盖整个数轴
如果不能覆盖输出-1

贪心策略：

    按照区间的左端点排序，

    第一个区间的开始不是1，无解，选择起点在s的最长的区间，然后下一个起点，是这个所选择区间的右端点。

```
    sort(a+1,a+n+1,cmp);//排序
    a[n+1].x=0x7fffffff;
    //t-是上次结尾的值，tmp，临时结尾最大值，ans，结果
    int t=0,tmp=0,ans=0;
    bool f=0;//是否更新的标志位
    for (int i=1;i<=n;++i)
    {
        //如果起点满足题意
        if (a[i].x<=t+1){
                //对于起点满足题意的，更新终点的最大值
                if (tmp<a[i].y)
                     tmp=a[i].y,f=1;
                //预判：如果下一个点不满足题意了，而且终点是更新过的，那么答案加1，如果下一个节点不满足题意，终点没有更新过，（也就是说出现了终点相同的情况，那么不增加）
                if (a[i+1].x>t+1 && f)
                    t=tmp,++ans,f=0;
            }
    }
    if (t<T)
     printf("-1\n"); else printf("%d\n",ans);
```

- 注释：巧妙的一点在于，结尾的判断，将结尾的元素的起点置为INF，可以巧妙的结束，不用再判断是否结尾。

##  nyist14

尽量多的选择不相交的区间

按照b1<=b2<=b3…的方式排序，然后从前向后遍历，每当遇到可以加入集合的区间，就把它加入集合。（集合代表解的集合）

证明：

我们对a1,a2……的关系分以下几种情况考虑：

1、a1>a2。此时区间2包含区间1。

这种情况下显然不会选择区间2，因为选择区间1会留下更多的剩余空间。

不仅区间2如此，以后所有区间中只要有一个 i 满足a1 > ai，i 都不要选。

即此种情况下，选择区间1是明智的，与策略一致。

2、排除情况1后，一定有a1<=a2<=a3……。
