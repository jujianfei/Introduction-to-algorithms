
## 最大的独立集

树的最大独立集。 对于一棵n个结点的无根树，选出尽量多的结点，
使得任何两个结点均不相邻（称为最大独立集），然后输入n-1条无向边，
输出一个最大独立集（如果有多解，则任意输出一组）。


用d(i)表示以i为根结点的子树的最大独立集大小。 

此时需要注意的是，本题的树是无根的：没有所谓的“父子”关系，而只有一些无向边。 
没关系，只要任选一个根r，无根树就变成了有根树，上述状态定义也就有意义了。

结点i只有两种决策：选和不选。 如果不选i，则问题转化为了求出i的所有儿子的d值再相加；
如果选i，则它的儿子全部不能选，问题转化为了求出i的所有孙子的d值之和。
换句话说，状态转移方程为：

```
first = 0;
for j in all node:
    if j <- gs(i):
        first += d(j)
second = 0
for j in all node:
    if j <- s(i):
        second += d(j)

d(i) = max(first + 1, second);
```

其中，gs(i)和s(i)分别为i的孙子集合与儿子集合，

代码应如何编写呢？上面的方程涉及“枚举结点i的所有儿子和所有孙子”，颇为不便。

其实可以换一个角度来看：不从i找s(i)和gs(i)的元素，而从s(i)和gs(i)的元素找i。 换句话说，当计算出一个d(i)后，用它去更新i的父亲和祖父结点的累加值 和 。 这样一来，每个结点甚至不必记录其子结点有哪些，只需记录父结点即可。 这就是前面提过的“刷表法”。

## 树的重心

对于一棵n个结点的无根树，找到一个点，使得把树变成以该点为根的有根树时，最大子树的结点数最小。 换句话说，删除这个点后最大连通块（一定是树）的结点数最小


和树的最大独立集问题类似，先任选一个结点作为根，把无根树变成有根树，然后设d(i)表示以i为根的子树的结点个数。 不难发现 。 程序实现也很简单：只需要一次DFS，在无根树转有根树的同时计算即可，连记忆化都不需要——因为本来就没有重复计算。那么，删除结点i后，最大的连通块有多少个结点呢？结点i的子树中最大的有max{d(j)}个结点，i的“上方子树”中有n-d(i)个结点，这样，在动态规划的过程中就可以顺便找出树的重心了。

## 树的最长路径

对于一棵n个结点的无根树，找到一条最长路径。 换句话说，要找到两个点，使得它们的距离最远。


随便找一个结点u，用DFS求出u的最远结点v，然后再用一次DFS求出v的最远结点w，则v-w就是最长路径

## Pr

- UVA-12186-工人的请愿书
- UVA-1220-hali的晚会
- UVA-1218-完美的服务
- POJ-1741-Tree
