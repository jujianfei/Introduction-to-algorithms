# 基础算法

### [有向图的API](DiGraph.cpp)

### [深度优先搜索](DirectedDFS.cpp)

### [深度优先搜索寻找路径](DepthFirstDirectedPaths.cpp)

### [广度优先搜索寻找路径](BreadthFirstDirectedPaths.cpp)

### [检查是否有环](DirectedCycle.cpp)

# Remarks

- DFS的顺序
  - 前序，就是在递归之前输出访问节点的信息
  - 后序，就是在递归之后输出访问节点的信息
  - 逆后续，就是后序逆置

- 这里检查是否有环，使用的是模拟栈的方法，注意和无向图的区别


### 拓扑排序

- [拓扑排序基于dfs的算法](http://blog.csdn.net/zlqdhrdhrdhr/article/details/52336534)

- 原图dfs得到后续，在逆后续中dfs

- [常用的topo排序的算法](critical_path.cpp)

不断寻找入度为零的点，并且去掉。如果在完成之前找不到入度为零的点，那么就存在环。



### [活动网络关键路径](critical_path.cpp)

- 首先要保证是一个DAG图
- 这种方法能够找到所有的关键活动组成的关键路径，当然如果只想找一条路径可以使用求DAG图上的最长路径的方法，参见最短路那一节。

```
  - 对每一个顶点(事件)来说
  - 一个事件的最早的时间是选择从开始点到这个点的最长的路径
  - Ee[i] = max{Ee[j]+dur<Ej,Ei>};//正向topo
  - 一个事件的最晚的时间是选择从这个点到结束点的最长的路径
  - El[i] = min{El[j]-dur<Ei,Ej>};//逆向topo
  - 对于每一个边(活动)来说
  - e[k] = Ee[i]//最早的时间
  - l[k] = El[j]–dur(<Ei, Ej>)//最晚的时间
```

