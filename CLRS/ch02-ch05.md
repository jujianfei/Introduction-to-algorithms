### 设计算法

- Pro 2-1-2

InsertionSort从大到小。
```
void InsertionSort(int n) {
    for (int i=1; i<n; i++) {
        int tmp = a[i];
        int j = i - 1;
        for (; j>=0; j--) {
            if (a[j] < tmp) {
                a[j+1] = a[j];
            } else {
                break;
            }
        }
        a[j+1] = tmp;
    }
}
```
- Pro 2-3-2

MergeSort使用哨兵。

```
int auxlo[20], auxhi[20];
#define INF 0x3f3f3f3f

void merger(int lo, int hi) {
    if (lo == hi) return;
    int mid = lo + (hi - lo) / 2;
    merger(lo, mid);
    merger(mid+1, hi);

    for (int i=lo; i<=mid; i++) auxlo[i] = a[i];
    for (int i=mid+1; i<=hi; i++) auxhi[i] = a[i];

    auxlo[mid+1] = auxhi[hi+1] = INF;
    int k = lo, p = lo, q = mid+1;
    while (k<=hi) {
        if (auxlo[p] < auxhi[q]) a[k++] = auxlo[p++];
        else                     a[k++] = auxhi[q++];
    }

}

void MergeSort(int n) {
    merger(0, n-1);
}

```



- Pro 4-1-4

最大连续子数组问题，如果修改定义，可以出现空数组。

先考虑原始的定义，不允许出现空的数组。

```

int A[10] = {-10,-20,-30,-1,-20,30,300,-40,-50,-60};

int find_max_crossarray(int low, int mid, int high, int &res_low, int &res_high) {
    int sum = 0, left_sum = -INF;
    for (int i=mid; i>=low; i--) {
        sum += A[i];
        if (sum > left_sum) {
            res_low = i;
            left_sum = sum;
        }
    }
    sum = 0;
    int right_sum = -INF;
    for (int i=mid+1; i<=high; i++) {
        sum += A[i];
        if (sum > right_sum) {
            res_high = i;
            right_sum = sum;
        }
    }
    return left_sum + right_sum;
}

int find_max_subarray(int low, int high, int &res_low, int &res_high) {
    if (low == high) {
        res_low = res_high = low;
        return A[low];
    }

    int mid = (low + high)/2;
    int left_low, left_high, right_low, right_high, cross_low, cross_high;
    int left_sum = find_max_subarray(low, mid, left_low, left_high);
    int right_sum = find_max_subarray(mid+1, high, right_low, right_high);
    int cross_sum = find_max_crossarray(low, mid, high, cross_low, cross_high);

    if (left_sum >= right_sum && left_sum >= left_sum) {
        res_low = left_low, res_high = left_high;
        return left_sum;
    } else if (right_sum >= left_sum && right_sum >= cross_sum) {
        res_low = right_low, res_high = right_high;
        return right_sum;
    } else {
        res_low = cross_low, res_high = cross_high;
        return cross_sum;
    }
}

int main() {
    int x=INF, y=INF;
    cout << find_max_subarray(0, 9, x, y) << endl;
    cout << x << y << endl;
}

```

修改定义，如果允许有空的元素呢？

给出一种比较搓的实现。

```
#include <iostream>
using namespace std;
#define INF 0x3f3f3f3f
int A[10] = {-10,-20,-30,-100000,-20,-30,-300,-40,-50,-60};


int find_max_crossarray(int low, int mid, int high, int &res_low, int &res_high) {
    res_low = res_high = -INF;
    int sum = 0, left_sum = 0;

    for (int i=mid; i>=low; i--) {
        sum += A[i];
        if (sum > left_sum) {
            res_low = i;
            left_sum = sum;
        }
    }
    sum = 0;
    int right_sum = 0;
    for (int i=mid+1; i<=high; i++) {
        sum += A[i];
        if (sum > right_sum) {
            res_high = i;
            right_sum = sum;
        }
    }
    return left_sum + right_sum;
}

int find_max_subarray(int low, int high, int &res_low, int &res_high) {
    if (low == high) {
        if (A[low] >= 0) {
            res_low = res_high = low;
            return A[low];
        } else {
            res_low = res_high = -INF;
            return 0;
        }

    }

    int mid = (low + high)/2;
    int left_low, left_high, right_low, right_high, cross_low, cross_high;
    int left_sum = find_max_subarray(low, mid, left_low, left_high);
    int right_sum = find_max_subarray(mid+1, high, right_low, right_high);
    int cross_sum = find_max_crossarray(low, mid, high, cross_low, cross_high);

    if (left_sum >= right_sum && left_sum >= left_sum) {
        res_low = left_low, res_high = left_high;
        return left_sum;
    } else if (right_sum >= left_sum && right_sum >= cross_sum) {
        res_low = right_low, res_high = right_high;
        return right_sum;
    } else {
        res_low = cross_low, res_high = cross_high;
        return cross_sum;
    }
}

int main() {
    int x=INF, y=INF;
    cout << find_max_subarray(0, 9, x, y) << endl;
    cout << x << " " << y << endl;
}

```




- Pro 4-1-5

为最大子数组问题，设计一个非递归，O(n)的算法。

如何将算法优化到线性级别

保存前缀的和，然后，通过不断遍历前缀和的过程中，保存一个前缀和的最小值，然后通过当前前缀和减去最小值的前缀和求出那个区间的和的大小，当然要维护这个前缀最小和，并记录整个遍历过程中，这些区间和的最大值。




### 矩阵乘法

- Pro 4-2-2

TODO：暂时跳过

实现Strassen算法。

