##[有向图的API](DiGraph.cpp)
##[有向图的深度优先搜索](DirectedDFS.cpp)
- [寻找路径](DepthFirstDirectedPaths.cpp)
- 深度优先搜索的时间复杂度是所有顶点的出度之和
##[有向图的广度优先搜索寻找路径](BreadthFirstDirectedPaths.cpp)
##[检查是否有环](DirectedCycle.cpp)
- 这里检查是否有环，使用的是模拟栈的方法，注意和无向图的区别

##DFS的顺序
- 前序，就是在递归之前输出访问节点的信息
- 后序，就是在递归之后输出访问节点的信息
- 逆后续，就是后序逆置
##拓扑排序
- 当且仅当是DAG图的时候才能进行拓扑排序
- 拓扑排序就是dfs的逆后续

- [拓扑排序基于dfs的算法](scckosaraju.cpp)-必须先判断是不是有环，此算法的复杂度与V+E成正比O(n+2m)
- [最常用的topo排序的算法](critical_path.cpp)另外还有一种算法是，不断寻找入度为零的点，并且去掉。如果在完成之前找不到入度为零的点，那么就存在环。每个顶点要进一次栈，出一次栈，每条边扫描一次且仅一次，其复杂度为 O(m)。所以，总的时间复杂度为 O(n+m)。


##[活动网络关键路径](critical_path.cpp)
- 首先要保证是一个DAG图
- 这种方法能够找到所有的关键活动组成的关键路径，当然如果只想找一条路径可以使用求DAG图上的最长路径的方法，参见最短路那一节
- 计算公式
```
  - 对每一个顶点(事件)来说
  - 一个事件的最早的时间是选择从开始点到这个点的最长的路径
  - Ee[i] = max{Ee[j]+dur<Ej,Ei>};//正向topo
  - 一个事件的最晚的时间是选择从这个点到结束点的最长的路径
  - El[i] = min{El[j]-dur<Ei,Ej>};//逆向topo
  - 对于每一个边(活动)来说
  - e[k] = Ee[i]//最早的时间
  - l[k] = El[j]–dur(<Ei, Ej>)//最晚的时间
```
##计算强联通分量

- [SCC_Kosaraju算法](scckosaraju.cpp)
  - 因为基于DFS，时间适合V+E成正比
- [SCC_Tarjan](sccTarjan.cpp)
- 利用强联通分量说明传递闭包
  - 存在一条v到w的路径等价于v->w是可达的(space proportional to V^2 and time proportional to V (V + E))

##[有向图中的欧拉回路基于dfs]

##[动态规划求解汉密尔顿回路](tsp_problem.cpp)
```
- 状态压缩，假设当前访问过的节点的集合压缩为S，当前所在的顶点是v
- 用dp[S][v]表示从v出发访问剩下的所有的节点最后回到0的最小的值
- dp[全集][0]=0;//遍历完成
- dp[S][v]=min{dp[{S}+u][u]+distance(v,u)}其中u不属于S二期v->u存在路径
```

