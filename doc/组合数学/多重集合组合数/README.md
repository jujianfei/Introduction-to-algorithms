
有n种物品，物品的价值是v[i], 每种有m[i]个，不同种类的物品可以相互区分，但是相同种类的物品无法区分，求要凑出target的价值有多少中解决方案。



## 版本一：多重集合组合数


有n种物品，第i种物品有ai个，不同种类的物品可以相互区分，但是相同种类的物品无法区分，从n个物品中取出m个的话，有多少种选择方案？相当于泛化版本中的价值都是1.
因为这个数一般比较大，一般mod一个数然后输出

```
    dp[i][j]:=从前i中物品中取出后j个的组合总数
```

二维数组的第一列全部是1，从前i个物品中取出0个总是有1种方案。

一般的思路是这样的

```
dp[i][j]=segam(k from 0 to min(a[i-1],j)) dp[i-1][j-k]
```

优化之后：

```
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(j-1-a[i-1]>=0)
            dp[i][j]=(dp[i][j-1]+dp[i-1][j]-dp[i-1][j-1-a[i-1]]+PRIME)%PRIME;
        else
            dp[i][j]=(dp[i][j-1]+dp[i-1][j])%PRIME
     }
}
```
TODO: 优化原理

## 版本二：变形

有n种钱币面值分别是ai，求凑出总数amount的总数是多少,相当于泛化版本中去掉了数量限制。
```

dp[i][j]:=前i中钱币凑出j的总数
dp[i][0]=1,第一列初始化为1；
前i种物品凑出0，都是有1种的解决方案
dp[0][j]=0, j from 1 to amount
dp[i][j]=dp[i][j-a[i-1]]+dp[i-1][j]
如果使用了本物品，前i种凑出j-a[i-1]的种类数目
如果没有使用本物品，前i-1种凑出j的种类数目

```