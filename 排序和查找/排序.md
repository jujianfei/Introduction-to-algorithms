#排序算法
[动态展示](http://zh.visualgo.net/sorting)
##冒泡排序(bublesort.cpp)

##选择排序

特点:交换次数最少的算法，线性级别

##插入排序
```C++
void insertsort(){
    for(int i=1;i<n;i++){
        int tmp=a[i];
        int k;
        for(k=i-1;k>=0;k--){
            if(a[k]>tmp){
                a[k+1]=a[k];//移动而不是交换，能够提高效率
            }else{//注意要break
                break;
            }
        }
        a[k+1]=tmp;
    }
}

```
特点

- 比较次数```n*n/4```，交换次数```n*n/4```
- 适合非随机的数组 部分有序的数组 小规模数组
- 基本上会比选择排序方法快一倍

##希尔排序
```
void shellsort(){
    int d=n/2;
    while(d>0){//不能是>1
        for(int i=d;i<n;i+=1){//这里的步进是d
            int tmp=a[i];
            int k;
            for(k=i-d;k>=0;k-=d){
                if(a[k]>tmp){
                    a[k+d]=a[k];
                }else{
                    break;
                }
            }
            a[k+d]=tmp;
        }
        d/=2;
    }
}
```
特点

- 算法的证明或者研究十分困难
- 思想是先让任意间隔d的元素有序,如果d很大，那么就能够交换距离比较远的元素
- 其他思路和插入排序相同


##归并排序
- 自底向上的归并排序
  - 说明：最后一个子数组的大小只有是在n的偶数倍的时候才会等于n，否则会比n小
  - 以下算法使用的是闭区间
```C++
void merge(int lo, int mid, int hi) {
    // copy to aux[]
    for (int k = lo; k <= hi; k++) {
        aux[k] = a[k]; 
    }
    // merge back to a[]
    int i = lo, j = mid+1;
    for (int k = lo; k <= hi; k++) {
        if      (i > mid)              a[k] = aux[j++];  // this copying is unneccessary
        else if (j > hi)               a[k] = aux[i++];
        else if (aux[j] < aux[i])      a[k] = aux[j++];
        else                           a[k] = aux[i++];
    }
}
void sort() {
    for (int n = 1; n < N; n = n+n) {
        for (int i = 0; i < N-n; i += n+n) {
            int lo = i;
            int m  = i+n-1;
            int hi = min(i+n+n-1, N-1);
            merge(a, aux, lo, m, hi);
        }
    }
}
```
- [分治递归的自顶向下的归并排序](mergesort.cpp)
  
  - 优化方案：对于小规模数组使用插入排序
  - 判断数组是否已经有序
  - 不讲数组来回的复制，而是采用两个一维数组回滚的解决方案

--------------------------------------------------------
##[快速排序](quicksort.cpp)

java的实现

```
void sort(int lo, int hi) { //闭区间
    if (hi <= lo) return;
    int j = partition(lo, hi);
    sort(lo, j-1);
    sort(j+1, hi);
}

// partition the subarray a[lo..hi] so that a[lo..j-1] <= a[j] <= a[j+1..hi]
// and return the index j.
private static int partition(int lo, int hi) {
    int i = lo;
    int j = hi + 1;
    int v = a[lo];
    while (true) { 

        // find item on lo to swap
        while (a[++i] < v))
            if (i == hi) break;

        // find item on hi to swap
        while (v < a[--j]))
            if (j == lo) break;      // redundant since a[lo] acts as sentinel

        // check if pointers cross
        if (i >= j) break;

        exch(a, i, j);
    }

    // put partitioning item v at a[j]
    exchange(a, lo, j);

    // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
    return j;
}
```
##应用

求第k小的元素


```
/**
 * Rearranges the array so that a[k] contains the kth smallest key;
 * a[0] through a[k-1] are less than (or equal to) a[k]; and
 * a[k+1] through a[N-1] are greater than (or equal to) a[k].
 */
 
int select(int k) {
    if (k < 0 || k >= a.length) { throw; }
    int lo = 0, hi = a.length - 1;
    while (hi > lo) {
        int i = partition(lo, hi);
        if      (i > k) hi = i - 1;
        else if (i < k) lo = i + 1;
        else return a[i];
    }
    return a[lo];
}
```


- 注意事项
  - 原地切分的效率更高，如果建立一个数组辅助分割也可以
  - 将交换操作改成，写入的操作，可以提高效率
  - 不能越界
  - 元素的随机性是效率的保障
  - 最好是左侧>=的时候停下，有边<=的时候停下，这一点在元素大量重复的情况下非常适合


- 算法改进
  - 小规模数组采用插入排序能够大幅提高性能
  - 三取样切分


###[快排的改进算法，三向切分的快速排序](3_partation_quick_sort.cpp)

![图片](http://algs4.cs.princeton.edu/23quicksort/images/partitioning3-overview.png)

```C++
void sort(int lo, int hi) { 
    if (hi <= lo) return;
    int lt = lo, gt = hi;
    Comparable v = a[lo];
    int i = lo;
    while (i <= gt) {
        int cmp = a[i].compareTo(v);
        if      (cmp < 0) exch(a, lt++, i++);
        else if (cmp > 0) exch(a, i, gt--);
        else              i++;
    }
    // a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]. 
    sort(a, lo, lt-1);
    sort(a, gt+1, hi);
    assert isSorted(a, lo, hi);
}

```
- 适合重复元素多的情况
##[堆排序](heap_sort.cpp)
- 从小到大堆排序的思想
  - 先构建大顶堆，构建的时候因为可以跳过大小为1的子堆，因此只需从n/2开始下沉操作就可构建堆
  - 不断的交换堆顶和堆的最后一个元素交换完成后再对堆顶元素sink，恢复堆
  - 注意恢复堆的时候，我们认为堆的大小已经小了1

##[优先队列](priority_queue.cpp)
- 我们可以像vector一样动态的改变堆的大小
- [索引优先队列](indexpriorityqueue.cpp)
  - 索引优先队列的使用情境：每个id对应一个距离，id各不相同，但是距离都可能会相同，我们按照每个id对应距离的大小对**id**进行建立优先队列的操作，并且能够实现下列的操作：
      - 改变一个队列中某个id的距离
      - 这个地方<algo4>的代码写的不是很清晰，但是对于C++来讲，因为有STL的make_heap算法，实现起来也就比较容易


##基数排序
- 其实和桶排序道理差不多，采用n个关键字进行排序
- 从小的关键子开始排序，将关键字相同的放入到一个队列中
- 如果有n个关键字，那么一共进行n轮收集
- 适用范围，内存的限制不是很大，关键字的个数有限可数，而且不是很多的情况
- 关键字的个数是k,复杂度O(k*n),同时使用空间O(n)
- 使用队列实现更加简单

##计数排序
- 统计数据的出现频率
- 计算元素的开始写入位置
- 根据写入位置写入到辅助数组
- 回写到原数组


#排序算法总结
![图片](http://algs4.cs.princeton.edu/25applications/images/sort-characteristics.png)

