
### 快速排序

- Pro 7-1-4

实现非递增的快速排序算法

```
int partation(int lo, int hi) {
    if (lo == hi) {
        return lo;
    }
    int tmp = a[lo];
    int i = lo;
    for (int j=lo+1; j<=hi; j++) {
        if (a[j] < tmp) {}
        else {
            i++;
            swap(a[i], a[j]);
        }
    }
    //1<x<=i -> a[x] >= piv
    swap(a[lo], a[i]);
    return i;
}


void QuickSort(int lo, int hi) {
    if (lo >= hi) return;
    int mid = partation(lo, hi);
    QuickSort(lo, mid-1);
    QuickSort(mid+1, hi);
}
```
### 线性时间排序

- Pro 

实现计数排序
```
int a[100] = {5, 1, 3, 5, 3, 4, 6, 8, 7, 9, 0, 0, 1, 2};
int  n = 15;
int hashing[10];
int res[10];
void CountSort() {
    for (int i=0; i<n; i++) hashing[a[i]]++;
    for (int i=1; i<10; i++) hashing[i] = hashing[i] + hashing[i-1];
    for (int i=n-1; i>=0; i--) {
        res[hashing[a[i]]] = a[i];
        hashing[a[i]]--;
    }
}
int main() {
    CountSort();
    for (int i=0; i<n; i++) cout << res[i] << " "; cout << endl;
}
```
- Pro 8-2-4

设计一个算法，能够对于任何的介于0到k之间的n个正数，先进行预处理，然后在 O(1) 时间内，回答输入的n个整数中有多少个落在[a..b]之间。算法预处理时间应该O(n+k)。

解：使用上述的hashing矩阵记录：在新的res矩阵中index应该出现的位置。
然后使用hashing[b] - hashing[a-1]即可

### 基数排序

- Pro

实现基数排序

从低位到高位使用计数排序，一共需要排n次。
n是分组的组数。

延伸：如何正确的确定分的组数？参考CLRS111


### 中位数和顺序统计量

- Pro

实现select，random-select的迭代版本，random-select的递归版本。
```
int partation(int lo, int hi) {
    if (lo == hi) { return lo; }
    int tmp = a[lo];
    int i = lo;
    for (int j=lo+1; j<=hi; j++) {
        if (a[j] > tmp) {}
        else {
            i++;
            swap(a[i], a[j]);
        }
    }
    swap(a[lo], a[i]);
    return i;
}
int Select(int lo, int hi, int k) {
    int piv = partation(lo, hi);
    if (k == piv-lo+1) {
        return a[piv];
    } else if(piv-lo+1 > k) { // 如果分界线是第 x 大的，x比k大，那么

        return Select(lo, piv-1, k);
    } else {
        return Select(piv+1, hi, k-(piv-lo+1));
    }
}
```
迭代版本
```
int Sel(int tar) {
    int b = 0, e = 9, k = tar;
    while (1) {
        cout << "now " << b << " " << e << " " << k << endl;
        int piv = partation(b, e);
        cout << "piv " << piv << endl;
        if (k == piv-b+1) return a[piv];
        else if(piv-b+1 > k) {
            e = piv - 1;
        } else {
            int tmpb = b;
            b = piv + 1;
            k = k-(piv-tmpb+1);
        }
    }
}
```
- Pro 9-2-4
给定一个数组，输出能够导致random-select最好的情况发生的一个划分序列。
```
int a[100] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};
int n = 10;
void Creat_seq(int lo, int hi) {
    if (lo >= hi) return;
    sort(a+lo, a+hi-1);
    int mid = lo + (hi-lo)/2;
    swap(a[lo], a[mid]);
    Creat_seq(lo+1, mid);
    Creat_seq(mid+1, hi);
}

int main() {
    Creat_seq(0, 9);
    for (int i=0; i<10; i++) cout << a[i] << " "; cout << endl;
}
```

- Pro 9-3-5

假如已经有个API，在最坏线性的时间，求解中位数，设计一个任意统计量的选择算法。

[这篇文章](http://blog.csdn.net/z84616995z/article/details/18889535)没怎么看懂。

我的思路：
根据找到的中位数，进行划分，然后递归的在左边或者右边进行寻找。


- Pro 9-3-8

X[1..n], Y[1..n] 都有n个有序的元素，设计O(lgN)的算法，找出这两个数组的中位数。规定如果是偶数个那么结果应当是前后两个数的平均数。

分治。