### Heap

delete(A, i)算法能够将i从节点从堆A中删除，设计一个O(lgN)的算法。

```
伪代码
HEAP-DELETE(A, i):
    if A[i] < A[A.heap-size]
        HEAP-INCREASE-KEY(A, i, A[A.heap-size])
        A.heap-size -= 1
    else
        A[i] = A[A.heap-size]
        A.heap-size -= 1
        MAX-HEAPIFY(A,i)
```

[详细解释](https://github.com/gzc/CLRS/blob/master/C06-Heapsort/6.5.md)

------------------------------


### 顺序统计量

- 最坏情况为线性的选择算法。

```C++
#include<iostream>  
#include<algorithm>  
using namespace std;  
int Select(int a[], int n,int k);  
int main(){  
    /*测试*/  
    int a[10] = { 8, 4,0, -89, -12, 0, 36, 789, 21, 54 };  
    cout << Select(a, 10,5) << endl;  
    return 0;  
}  
int Partition(int a[],int low,int high, int x){  //这里数组a是[low,high)的，注意右边界最多到a[high-1]，  
    /*利用x将数组划分为2部分*/  
    int i = low;  
    high--;  
    while (a[i]!= x) i++;  
    swap(a[low], a[i]);  //将基准移到首位置  
    while (low < high){  
        while (low < high&&a[high] >= x) high--;  
        a[low] = a[high];  
        while (low < high&&a[low] <= x) low++;  
        a[high] = a[low];  
    }  
    a[low] = x;  
    return low;   
}  
int S_sort(int a[],int low,int high, int k){  
    int i, j,x,q,n;  
    n = high - low;                                //n为数组a[low...high]元素个数,注意右边最多取到a[high-1]  
    if (n < 5){      //元素小于5时候单独处理  
        sort(a + low, a + high);  
        return a[low +k-1];  
    }  
    for (i = 0; i <n/ 5; i++){  
        sort(a + low+i * 5, a + low+i * 5 + 5);   //对每组数据排序  
        swap(a[low+i], a[low+i * 5 + 2]);        //中位数移到前面  
    }  
    x = S_sort(a, low,low+n/5, n/10+1);          //寻找中位数的中位数、n/10+1非常重要，避免n<10时n/10==0此时会出现问题  
    j = Partition(a, low, high, x);             //根据x将数组a划分为2部分，j为x所在数组下标  
    q = j - low + 1;                           // q为小于或者等于x元素的个数  
    if (q == k)  
        return x;  
    else if (q>k)  
        return S_sort(a, low, j + 1, k);  
    else  
        return S_sort(a, j + 1, high, k - q);  
}  
int Select(int a[], int n, int k){  
    return S_sort(a, 0, n, k);  
} 
```

由于每次划分至少有3n/10-6个元素大于x,3n/10-6个元素小于x，从而下次递归调用规模至多为7n/10+6,得到递归式：
T(n)<=T(n/5)+T(7n/10-+6)+O(n),T(1)=O(1).最后解得T(n)=O(n).于是得到了最坏情况为线性时间复杂度。

- Pro 9-3-5




- Pro 9-3-6

O(klgn)时间内求出所有的K分位数。

![i](http://img.blog.csdn.net/20131231095736921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloZW5haXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


- Pro 9-3-7

设计O(n)的算法，在互异S集合内找最接近中位数的K个元素，

计算出中位数median，将所有数减去median,再取绝对值，用SELECT计算出第k小数字y，遍历数组，取出所有绝对值小于等于y的


- Pro 9-3-8

X[1..n]和Y[1..n]为两个数组，每个都包含n个有序的元素，设计一个O(lgN)时间的算法，找到数组X和Y中，所有2n个元素的中位数。

解：分治。

```
def two_array_median(a, b):
    if len(a) == 1:
        return min(a[0], b[0])

    m = median_index(len(a))
    i = m + 1
    if a[m] < b[m]:
        return two_array_median(a[-i:], b[:i])
    else:
        return two_array_median(a[:i], b[-i:])

def median_index(n):
    if n % 2:
        return n // 2
    else:
        return n // 2 - 1
```

### 链表

- Pro 10-3-2：

单数组表示的链表，实现AllocObj，和FreeObj过程。

实现的是多数组表示的链表。

```Python
#include <bits/stdc++.h>
#define N 5
using namespace std;

struct Node {
    int val = 0;
    int next = -1;
    int pre = -1;
};
Node a[N];

// 从0开始的
int head_of_free = 1;
int head_of_obj = 0;

void init() {
    for (int i=1; i<N; i++) a[i].next = i + 1;
    a[N-1].next = -1; // -1 代表是 null
    a[0].next = -1; // 这个节点是一个dummy节点
}

void alloc(int value) {
    if (head_of_free == -1) {
        cout << "no sapace left" << endl;
        return;
    }
    int next_index = a[head_of_free].next;
    // 将元素使用头插法插入到obj链表中

    a[head_of_free].next = head_of_obj;
    a[head_of_free].val = value;
    a[head_of_obj].pre = head_of_free;
    head_of_obj = head_of_free;
    head_of_free = next_index;
}
void display() {
    cout << "head of free :" << head_of_free << endl;
    cout << "head of obj :" << head_of_obj << endl;
    for (int i=0; i<N; i++) {
        cout << a[i].val << " " ;
    } cout << endl;
    for (int i=0; i<N; i++) {
        cout << a[i].pre << " " ;
    } cout << endl;
    for (int i=0; i<N; i++) {
        cout << a[i].next << " " ;
    } cout << endl;
}
void delloc(int tar_index) { // 必须保证所要删除的元素的index是在数组中的
    // 假设输入是合法的
    if (tar_index == head_of_obj) { // 所要删除的就是head
        head_of_obj = a[head_of_obj].next;
        a[tar_index].val = 0;
        a[tar_index].next = head_of_free;
        head_of_free = tar_index;
    } else { //
        int pre_index = a[tar_index].pre;
        int next_index = a[tar_index].next;
        a[pre_index].next = next_index;
        a[next_index].pre = pre_index;
        a[tar_index].val = 0;
        a[tar_index].next = head_of_free;
        head_of_free = tar_index;
    }
}
int main() {
    init();
    alloc(100);
    alloc(200);
    alloc(300);
    alloc(400);
    //alloc(500);
    delloc(2);
    delloc(1);
    delloc(3);
    delloc(4);
    display();
}

```

- Pro 10-3-3：

使用多数组表示的链表，为了让数据紧凑的靠前，修改AllocObj和FreeObj过程。


这个题目我们必须假设链表中的元素的顺序是没有要求的。

假设原来的链表中的1-f是obj，f+1-n是free，那么alloc过程，是选择f+1的位置，delloc假设的是i位置，那么这个位置就留下了一个空的位置I，因此可以，将f位置（尾部）的元素放到这个空的位置。

- Pro 10-3-5:

给定一个多数组链表，整理这个链表，让数据占据前面的位置，自由表占据后边的位置。时间O(n)，空间O(1)。

首先考虑这么一个过程，给定一个array中有两类的对象，目的是让他们区分开来。第一类放在开头，第二类放在结尾。

维护两个指针p1, p2, 0-p1-1之间的是第一类，p2+1~n之间的是第二类，当前位置是p1，如果是第二类，交换，然后移动p2即可。

所以剩余的问题就是如何区分这个对象是位于obj，还是free，其实free中的pre是没有使用的，因此可以指定一个特殊的值来标记，就好了。

最后完成上述步骤之后，整理链表即可。

### 二叉树

- Pro 10-4-5:

二叉树，保存了parent节点的情况下，非递归的遍历，空间O(1)，不能修改树。

思路：
```
prev记录上次visit的点，每次移动的时候更新，后面的实现省略这一步

while root:
    
    if root.parent == prev:
        访问这个root
        然后依次看left，right，parent是不是空，不是空，那么访问相应的对象
    elif root.left == prev:
        然后依次看right，parent是不是空，不是空，那么访问相应的对象
    else: (root.right == prev)
        root = root.parent

```
### TODO:

- Ch11 Hashing Algorithms.




